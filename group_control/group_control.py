import os
import json
import re
import asyncio
from datetime import datetime
from telegram import Update, ChatPermissions
from telegram.ext import ContextTypes

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡ Ùˆ Ø¯Ø³ØªØ±Ø³ÛŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SUDO_IDS = [8588347189]  # Ø¢ÛŒØ¯ÛŒ Ø³ÙˆØ¯ÙˆÛŒ Ø§ØµÙ„ÛŒ

async def _is_admin_or_sudo(context, chat_id: int, user_id: int) -> bool:
    """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¯ÛŒØ± ÛŒØ§ Ø³ÙˆØ¯Ùˆ"""
    if user_id in SUDO_IDS:
        return True
    try:
        member = await context.bot.get_chat_member(chat_id, user_id)
        return member.status in ("administrator", "creator")
    except:
        return False

def _is_vip(chat_id: int, user_id: int) -> bool:
    try:
        return user_id in VIPS.get(str(chat_id), [])
    except:
        return False

async def _has_full_access(context, chat_id: int, user_id: int) -> bool:
    """Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ú©Ø§Ù…Ù„"""
    if user_id in SUDO_IDS:
        return True
    if await _is_admin_or_sudo(context, chat_id, user_id):
        return True
    if _is_vip(chat_id, user_id):
        return True
    return False

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
LOCK_FILE = os.path.join(BASE_DIR, "group_locks.json")

if not os.path.exists(LOCK_FILE):
    with open(LOCK_FILE, "w", encoding="utf-8") as f:
        json.dump({}, f, ensure_ascii=False, indent=2)

def _load_json(path, default=None):
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception as e:
        print(f"[âš ï¸] Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† {path}: {e}")
    return default or {}

def _save_json(path, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[âš ï¸] Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ {path}: {e}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ø§Ù†ÙˆØ§Ø¹ Ù‚ÙÙ„â€ŒÙ‡Ø§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

LOCK_TYPES = {
    "links": "Ù„ÛŒÙ†Ú©",
    "photos": "Ø¹Ú©Ø³",
    "videos": "ÙˆÛŒØ¯ÛŒÙˆ",
    "files": "ÙØ§ÛŒÙ„",
    "voices": "ÙˆÛŒØ³",
    "stickers": "Ø§Ø³ØªÛŒÚ©Ø±",
    "gifs": "Ú¯ÛŒÙ",
    "media": "Ø±Ø³Ø§Ù†Ù‡",
    "forward": "ÙÙˆØ±ÙˆØ§Ø±Ø¯",
    "ads": "ØªØ¨Ù„ÛŒØº",
    "usernames": "ÛŒÙˆØ²Ø±Ù†ÛŒÙ…",
    "mention": "Ù…Ù†Ø´Ù†",
    "arabic": "Ø¹Ø±Ø¨ÛŒ",
    "english": "Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ",
    "text": "Ù…ØªÙ†",
    "audio": "Ù…ÙˆØ²ÛŒÚ©",
    "emoji": "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
    "caption": "Ú©Ù¾Ø´Ù†",
    "reply": "Ø±ÛŒÙ¾Ù„Ø§ÛŒ",
    "voicechat": "ÙˆÛŒØ³ Ú†Øª",
    "location": "Ù…Ú©Ø§Ù†",
    "contact": "Ù…Ø®Ø§Ø·Ø¨",
    "poll": "Ù†Ø¸Ø±Ø³Ù†Ø¬ÛŒ",
    "bots": "Ø±Ø¨Ø§Øª",
    "join": "ÙˆØ±ÙˆØ¯"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ø¹Ù…Ù„ÛŒØ§Øª Ø±ÙˆÛŒ Ù‚ÙÙ„â€ŒÙ‡Ø§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

LOCKS = _load_json(LOCK_FILE, {})

def _get_locks(chat_id: int):
    return LOCKS.get(str(chat_id), {})

def _set_lock(chat_id: int, key: str, status: bool):
    """Ø°Ø®ÛŒØ±Ù‡ Ù‚ÙÙ„ Ø¯Ø± Ø­Ø§ÙØ¸Ù‡ Ùˆ ÙØ§ÛŒÙ„"""
    cid = str(chat_id)
    if cid not in LOCKS:
        LOCKS[cid] = {}
    LOCKS[cid][key] = bool(status)
    _save_json(LOCK_FILE, LOCKS)

def _is_locked(chat_id: int, key: str) -> bool:
    """Ø¨Ø±Ø±Ø³ÛŒ ÙØ¹Ø§Ù„ Ø¨ÙˆØ¯Ù† Ù‚ÙÙ„"""
    return LOCKS.get(str(chat_id), {}).get(key, False)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…Ù…Ù†ÙˆØ¹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def _del_msg(update: Update, warn_text: str = None):
    try:
        msg = update.message
        user = update.effective_user
        await msg.delete()
        if warn_text:
            warn = await msg.chat.send_message(
                f"{warn_text}\nğŸ‘¤ {user.first_name}",
                parse_mode="HTML"
            )
            await asyncio.sleep(4)
            await warn.delete()
    except Exception as e:
        print(f"[Delete Error] {e}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ø§Ø¹Ù…Ø§Ù„ Ù‚ÙÙ„â€ŒÙ‡Ø§ Ø±ÙˆÛŒ Ù¾ÛŒØ§Ù… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def check_message_locks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø±Ø±Ø³ÛŒ Ù¾ÛŒØ§Ù… Ùˆ Ø§Ø¹Ù…Ø§Ù„ Ù‚ÙÙ„â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„"""
    if not update.message:
        return

    msg = update.message
    text = (msg.text or msg.caption or "").lower()
    chat = msg.chat
    user = msg.from_user

    locks = _get_locks(chat.id)
    if not any(locks.values()):
        return

    # Ù…Ø¯ÛŒØ±Ù‡Ø§ Ùˆ Ø³ÙˆØ¯ÙˆÙ‡Ø§ Ù…Ø³ØªØ«Ù†ÛŒ Ù‡Ø³ØªÙ†Ø¯
    if await _is_admin_or_sudo(context, chat.id, user.id):
        return

    # ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ§Ù…
    has_photo = bool(msg.photo)
    has_video = bool(msg.video)
    has_doc = bool(msg.document)
    has_voice = bool(msg.voice)
    has_anim = bool(msg.animation)
    has_stick = bool(msg.sticker)
    has_fwd = bool(msg.forward_date)

    # ğŸš« Ù‚ÙÙ„ Ù„ÛŒÙ†Ú©
    if locks.get("links") and any(x in text for x in ["http://", "https://", "t.me", "telegram.me"]):
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ Ù„ÛŒÙ†Ú© Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

    # ğŸš« ØªØ¨Ù„ÛŒØº
    if locks.get("ads") and any(x in text for x in ["joinchat", "promo", "invite", "bot?start=", "channel"]):
        return await _del_msg(update, "ğŸš« ØªØ¨Ù„ÛŒØºØ§Øª Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

    # ğŸš« Ø±Ø³Ø§Ù†Ù‡â€ŒÙ‡Ø§
    if locks.get("photos") and has_photo:
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("videos") and has_video:
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ ÙˆÛŒØ¯ÛŒÙˆ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("files") and has_doc:
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("voices") and has_voice:
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ ÙˆÛŒØ³ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("stickers") and has_stick:
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ Ø§Ø³ØªÛŒÚ©Ø± Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("gifs") and has_anim:
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ Ú¯ÛŒÙ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("forward") and has_fwd:
        return await _del_msg(update, "ğŸš« ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ù¾ÛŒØ§Ù… Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

    # ğŸš« Ù…Ù†Ø´Ù† / ÛŒÙˆØ²Ø±Ù†ÛŒÙ…
    if (locks.get("usernames") or locks.get("mention")) and "@" in text:
        return await _del_msg(update, "ğŸš« Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² @ ÛŒØ§ Ù…Ù†Ø´Ù† Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

    # ğŸš« Ø­Ø±ÙˆÙ Ø¹Ø±Ø¨ÛŒ / Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ
    if locks.get("arabic") and any("\u0600" <= c <= "\u06FF" for c in text):
        return await _del_msg(update, "ğŸš« Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø­Ø±ÙˆÙ Ø¹Ø±Ø¨ÛŒ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("english") and any("a" <= c <= "z" or "A" <= c <= "Z" for c in text):
        return await _del_msg(update, "ğŸš« Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø­Ø±ÙˆÙ Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

    # ğŸš« Ú©Ù¾Ø´Ù† / Ø±ÛŒÙ¾Ù„Ø§ÛŒ
    if locks.get("caption") and msg.caption:
        return await _del_msg(update, "ğŸš« Ú©Ù¾Ø´Ù†â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")
    if locks.get("reply") and msg.reply_to_message:
        return await _del_msg(update, "ğŸš« Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù† Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

    # ğŸš« ÙÙ‚Ø· Ø§ÛŒÙ…ÙˆØ¬ÛŒ
    if locks.get("emoji"):
        emoji_pattern = re.compile(r"[\U00010000-\U0010ffff]", flags=re.UNICODE)
        if text and all(emoji_pattern.match(c) for c in text if not c.isspace()):
            return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ ÙÙ‚Ø· Ø§ÛŒÙ…ÙˆØ¬ÛŒ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª.")

    # ğŸš« Ù¾ÛŒØ§Ù… Ù…ØªÙ†ÛŒ
    if locks.get("text") and text and not (has_photo or has_video or has_doc):
        return await _del_msg(update, "ğŸš« Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ØªÙ†ÛŒ Ù…Ù…Ù†ÙˆØ¹ Ø§Ø³Øª.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ÙØ¹Ø§Ù„ Ùˆ ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ù‚ÙÙ„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def handle_lock(update: Update, context: ContextTypes.DEFAULT_TYPE, key: str):
    chat = update.effective_chat
    user = update.effective_user

    if not await _has_full_access(context, chat.id, user.id):
        return await update.message.reply_text("ğŸš« ÙÙ‚Ø· Ù…Ø¯ÛŒØ±Ø§Ù† ÛŒØ§ Ø³ÙˆØ¯ÙˆÙ‡Ø§ Ù…Ø¬Ø§Ø²Ù†Ø¯.")

    if key not in LOCK_TYPES:
        return await update.message.reply_text("âš ï¸ Ù†ÙˆØ¹ Ù‚ÙÙ„ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.")

    if _is_locked(chat.id, key):
        return await update.message.reply_text(f"ğŸ”’ Ù‚ÙÙ„ {LOCK_TYPES[key]} Ø§Ø² Ù‚Ø¨Ù„ ÙØ¹Ø§Ù„ Ø§Ø³Øª.")
    _set_lock(chat.id, key, True)
    await update.message.reply_text(f"âœ… Ù‚ÙÙ„ {LOCK_TYPES[key]} ÙØ¹Ø§Ù„ Ø´Ø¯.")

async def handle_unlock(update: Update, context: ContextTypes.DEFAULT_TYPE, key: str):
    chat = update.effective_chat
    user = update.effective_user

    if not await _has_full_access(context, chat.id, user.id):
        return await update.message.reply_text("ğŸš« ÙÙ‚Ø· Ù…Ø¯ÛŒØ±Ø§Ù† ÛŒØ§ Ø³ÙˆØ¯ÙˆÙ‡Ø§ Ù…Ø¬Ø§Ø²Ù†Ø¯.")

    if key not in LOCK_TYPES:
        return await update.message.reply_text("âš ï¸ Ù†ÙˆØ¹ Ù‚ÙÙ„ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.")

    if not _is_locked(chat.id, key):
        return await update.message.reply_text(f"ğŸ”“ Ù‚ÙÙ„ {LOCK_TYPES[key]} Ø§Ø² Ù‚Ø¨Ù„ Ø¨Ø§Ø² Ø§Ø³Øª.")
    _set_lock(chat.id, key, False)
    await update.message.reply_text(f"ğŸ”“ Ù‚ÙÙ„ {LOCK_TYPES[key]} Ø¨Ø§Ø² Ø´Ø¯.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ø¯Ø³ØªÙˆØ±Ø§Øª Ù…ØªÙ†ÛŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def handle_lock_commands(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ´Ø®ÛŒØµ Ø¯Ø³ØªÙˆØ± Ù‚ÙÙ„ / Ø¨Ø§Ø²Ú©Ø±Ø¯Ù†"""
    text = (update.message.text or "").strip().lower()

    for key, fa in LOCK_TYPES.items():
        if text == f"Ù‚ÙÙ„ {fa}":
            return await handle_lock(update, context, key)
        if text in [f"Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† {fa}", f"Ø¨Ø§Ø²Ú©Ø±Ø¯Ù† {fa}"]:
            return await handle_unlock(update, context, key)

    await update.message.reply_text("âš ï¸ Ø¯Ø³ØªÙˆØ± Ù‚ÙÙ„ ÛŒØ§ Ø¨Ø§Ø²Ú©Ø±Ø¯Ù† Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.")
