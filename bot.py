import asyncio
import os
import random
import zipfile
from datetime import datetime
from telegram import Update, InputFile
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ContextTypes, filters
)
import aiofiles

# üì¶ ŸÖÿß⁄òŸàŸÑ‚ÄåŸáÿß
from memory_manager import (
    init_files, load_data, save_data, learn, shadow_learn,
    get_reply, set_mode, get_stats, enhance_sentence,
    generate_sentence, list_phrases
)
from jokes_manager import save_joke, list_jokes
from fortune_manager import save_fortune, list_fortunes
from group_manager import register_group_activity, get_group_stats
from ai_learning import auto_learn_from_text
from smart_reply import detect_emotion, smart_response

# üéØ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ Ÿæÿß€åŸá
TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID", "7089376754"))
init_files()

status = {
    "active": True,
    "learning": True,
    "welcome": True,
    "locked": False
}

# ======================= ‚ú≥Ô∏è ÿ¥ÿ±Ÿàÿπ Ÿà Ÿæ€åÿßŸÖ ŸÅÿπÿßŸÑ‚Äåÿ≥ÿßÿ≤€å =======================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ü§ñ ÿÆŸÜ⁄ØŸàŸÑ ŸÅÿßÿ±ÿ≥€å 8.5.1 Cloud+ Supreme Pro Stable+\n"
        "üìò ÿ®ÿ±ÿß€å ÿØ€åÿØŸÜ ŸÑ€åÿ≥ÿ™ ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™ ÿ®ŸÜŸà€åÿ≥: ÿ±ÿßŸáŸÜŸÖÿß"
    )


async def notify_admin_on_startup(app):
    try:
        await app.bot.send_message(
            chat_id=ADMIN_ID,
            text="üöÄ ÿ±ÿ®ÿßÿ™ ÿÆŸÜ⁄ØŸàŸÑ 8.5.1 Cloud+ Supreme Pro Stable+ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÅÿπÿßŸÑ ÿ¥ÿØ ‚úÖ"
        )
        print("[INFO] Startup notification sent ‚úÖ")
    except Exception as e:
        print(f"[ERROR] Admin notify failed: {e}")


# ======================= ‚öôÔ∏è ÿÆÿ∑ÿß€åÿßÿ® ÿÆŸàÿØ⁄©ÿßÿ± =======================
async def handle_error(update: object, context: ContextTypes.DEFAULT_TYPE):
    error_text = f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿ±ÿ®ÿßÿ™:\n\n{context.error}"
    print(error_text)
    try:
        await context.bot.send_message(chat_id=ADMIN_ID, text=error_text)
    except:
        pass


# ======================= üìò ÿ±ÿßŸáŸÜŸÖÿß =======================
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "üìò ÿ±ÿßŸáŸÜŸÖÿß€å ÿÆŸÜ⁄ØŸàŸÑ ŸÅÿßÿ±ÿ≥€å 8.5.1 Cloud+ Supreme Pro Stable+\n\n"
        "üß† €åÿßÿØ⁄Ø€åÿ±€å:\n"
        "‚ñ™Ô∏è €åÿßÿØÿ®⁄Ø€åÿ± ÿ¨ŸÖŸÑŸá ÿ≥Ÿæÿ≥ ÿØÿ± ÿÆÿ∑Ÿàÿ∑ ÿ®ÿπÿØ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ±Ÿà ÿ®ŸÜŸà€åÿ≥\n"
        "‚ñ™Ô∏è ŸÑ€åÿ≥ÿ™ ‚Üí ŸÜŸÖÿß€åÿ¥ ÿ¨ŸÖŸÑÿßÿ™ €åÿßÿØ⁄Øÿ±ŸÅÿ™Ÿá‚Äåÿ¥ÿØŸá\n"
        "‚ñ™Ô∏è ÿ¨ŸÖŸÑŸá ÿ®ÿ≥ÿßÿ≤ ‚Üí ÿ≥ÿßÿÆÿ™ ÿ¨ŸÖŸÑŸá ÿ™ÿµÿßÿØŸÅ€å\n\n"
        "üòÇ ÿ¨Ÿà⁄© Ÿà ŸÅÿßŸÑ:\n"
        "‚ñ™Ô∏è ÿ´ÿ®ÿ™ ÿ¨Ÿà⁄© €åÿß ÿ´ÿ®ÿ™ ŸÅÿßŸÑ ÿ®ÿß ÿ±€åŸæŸÑÿß€å\n"
        "‚ñ™Ô∏è ŸÑ€åÿ≥ÿ™ ÿ¨Ÿà⁄©‚ÄåŸáÿß Ÿà ŸÑ€åÿ≥ÿ™ ŸÅÿßŸÑ‚ÄåŸáÿß\n"
        "‚ñ™Ô∏è ÿ®ŸÜŸà€åÿ≥ ¬´ÿ¨Ÿà⁄©¬ª €åÿß ¬´ŸÅÿßŸÑ¬ª ÿ®ÿ±ÿß€å ÿ™ÿµÿßÿØŸÅ€å\n\n"
        "‚òÅÔ∏è ÿ®⁄©‚Äåÿ¢Ÿæ:\n"
        "‚ñ´Ô∏è ÿÆŸàÿØ⁄©ÿßÿ± Ÿáÿ± €±€≤ ÿ≥ÿßÿπÿ™ ÿ®ÿ±ÿß€å ÿ≥ŸàÿØŸà\n"
        "‚ñ´Ô∏è /cloudsync ‚Üí ÿ®⁄©‚Äåÿ¢Ÿæ ÿßÿ®ÿ±€å ÿØÿ≥ÿ™€å\n"
        "‚ñ´Ô∏è ÿ¥ÿßŸÖŸÑ jsonÿå ÿπ⁄©ÿ≥ÿå ÿµÿØÿß Ÿà ÿßÿ≥ÿ™€å⁄©ÿ±Ÿáÿß\n\n"
        "‚öôÔ∏è ŸÖÿØ€åÿ±€åÿ™:\n"
        "‚ñ™Ô∏è /toggle ‚Üí ÿ±Ÿàÿ¥ŸÜ/ÿÆÿßŸÖŸàÿ¥ ⁄©ÿ±ÿØŸÜ ÿ±ÿ®ÿßÿ™\n"
        "‚ñ™Ô∏è /welcome ‚Üí ŸÅÿπÿßŸÑ/ÿ∫€åÿ±ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿÆŸàÿ¥ÿßŸÖÿØ\n"
        "‚ñ™Ô∏è /mode ÿ¥ŸàÿÆ / ÿ∫ŸÖ⁄Ø€åŸÜ / ŸÜÿ±ŸÖÿßŸÑ / ÿ®€å‚ÄåÿßÿØÿ®\n"
        "‚ñ™Ô∏è /stats ‚Üí ÿ¢ŸÖÿßÿ± ÿÆŸÑÿßÿµŸá\n"
        "‚ñ™Ô∏è /fullstats ‚Üí ÿ¢ŸÖÿßÿ± ⁄©ÿßŸÖŸÑ ⁄Øÿ±ŸàŸá‚ÄåŸáÿß\n"
        "‚ñ™Ô∏è /backup ‚Üí ÿ®⁄©‚Äåÿ¢Ÿæ ZIP ÿØÿ± ⁄Üÿ™\n"
        "‚ñ™Ô∏è /reset ‚Üí Ÿæÿß⁄©‚Äå⁄©ÿ±ÿØŸÜ ⁄©ÿßŸÖŸÑ ÿØÿßÿØŸá‚ÄåŸáÿß\n"
        "‚ñ™Ô∏è /reload ‚Üí ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ŸÖÿ¨ÿØÿØ ÿ≠ÿßŸÅÿ∏Ÿá\n"
        "‚ñ™Ô∏è /broadcast ‚Üí ÿßÿ±ÿ≥ÿßŸÑ ŸáŸÖ⁄ØÿßŸÜ€å\n"
        "‚ñ™Ô∏è /leave ‚Üí ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ⁄Øÿ±ŸàŸá\n"
    )
    await update.message.reply_text(text, parse_mode="Markdown")


# ======================= üé≠ ÿ™ÿ∫€å€åÿ± ŸÖŸàÿØ =======================
async def mode_change(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        return await update.message.reply_text("üé≠ ÿßÿ≥ÿ™ŸÅÿßÿØŸá: /mode ÿ¥ŸàÿÆ / ÿ®€å‚ÄåÿßÿØÿ® / ÿ∫ŸÖ⁄Ø€åŸÜ / ŸÜÿ±ŸÖÿßŸÑ")

    mood = context.args[0].lower()
    if mood in ["ÿ¥ŸàÿÆ", "ÿ®€å‚ÄåÿßÿØÿ®", "ÿ∫ŸÖ⁄Ø€åŸÜ", "ŸÜÿ±ŸÖÿßŸÑ"]:
        set_mode(mood)
        await update.message.reply_text(f"üé≠ ŸÖŸàÿØ ÿ®Ÿá {mood} ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ üòé")
    else:
        await update.message.reply_text("‚ùå ŸÖŸàÿØ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™!")


# ======================= ‚öôÔ∏è ⁄©ŸÜÿ™ÿ±ŸÑ Ÿàÿ∂ÿπ€åÿ™ =======================
async def toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    status["active"] = not status["active"]
    await update.message.reply_text("‚úÖ ŸÅÿπÿßŸÑ ÿ¥ÿØ!" if status["active"] else "üò¥ ÿÆÿßŸÖŸàÿ¥ ÿ¥ÿØ!")


async def toggle_welcome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    status["welcome"] = not status["welcome"]
    await update.message.reply_text("üëã ÿÆŸàÿ¥ÿßŸÖÿØ ŸÅÿπÿßŸÑ ÿ¥ÿØ!" if status["welcome"] else "üö´ ÿÆŸàÿ¥ÿßŸÖÿØ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØ!")


async def lock_learning(update: Update, context: ContextTypes.DEFAULT_TYPE):
    status["locked"] = True
    await update.message.reply_text("üîí €åÿßÿØ⁄Ø€åÿ±€å ŸÇŸÅŸÑ ÿ¥ÿØ!")


async def unlock_learning(update: Update, context: ContextTypes.DEFAULT_TYPE):
    status["locked"] = False
    await update.message.reply_text("üîì €åÿßÿØ⁄Ø€åÿ±€å ÿ®ÿßÿ≤ ÿ¥ÿØ!")


# ======================= üë§ ÿ´ÿ®ÿ™ ⁄©ÿßÿ±ÿ®ÿ± =======================
def register_user(user_id):
    """ÿ´ÿ®ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿØÿ± ÿ≠ÿßŸÅÿ∏Ÿá"""
    data = load_data("memory.json")
    users = data.get("users", [])
    if user_id not in users:
        users.append(user_id)
        data["users"] = users
        save_data("memory.json", data)


# ======================= üìä ÿ¢ŸÖÿßÿ± ÿÆŸÑÿßÿµŸá =======================
async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = get_stats()
    memory = load_data("memory.json")
    groups = len(load_data("group_data.json").get("groups", []))
    users = len(memory.get("users", []))
    msg = (
        f"üìä ÿ¢ŸÖÿßÿ± ÿÆŸÜ⁄ØŸàŸÑ:\n"
        f"üë§ ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ: {users}\n"
        f"üë• ⁄Øÿ±ŸàŸá‚ÄåŸáÿß: {groups}\n"
        f"üß© ÿ¨ŸÖŸÑÿßÿ™: {data['phrases']}\n"
        f"üí¨ Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß: {data['responses']}\n"
        f"üé≠ ŸÖŸàÿØ ŸÅÿπŸÑ€å: {data['mode']}"
    )
    await update.message.reply_text(msg)


# ======================= üìä ÿ¢ŸÖÿßÿ± ⁄©ÿßŸÖŸÑ ⁄Øÿ±ŸàŸá‚ÄåŸáÿß =======================
async def fullstats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        data = load_data("group_data.json")
        groups = data.get("groups", {})

        if isinstance(groups, list):
            if not groups:
                return await update.message.reply_text("‚ÑπÔ∏è ŸáŸÜŸàÿ≤ Ÿá€å⁄Ü ⁄Øÿ±ŸàŸá€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá.")
            text = "üìà ÿ¢ŸÖÿßÿ± ⁄©ÿßŸÖŸÑ ⁄Øÿ±ŸàŸá‚ÄåŸáÿß:\n\n"
            for g in groups:
                gid = g.get("id", "ŸÜÿßŸÖÿ¥ÿÆÿµ")
                title = g.get("title", f"Group_{gid}")
                members = len(g.get("members", []))
                last = g.get("last_active", "ŸÜÿßŸÖÿ¥ÿÆÿµ")
                try:
                    chat = await context.bot.get_chat(gid)
                    if chat.title:
                        title = chat.title
                except:
                    pass
                text += f"üè† ⁄Øÿ±ŸàŸá: {title}\nüë• ÿßÿπÿ∂ÿß: {members}\nüïì ÿ¢ÿÆÿ±€åŸÜ ŸÅÿπÿßŸÑ€åÿ™: {last}\n\n"
        elif isinstance(groups, dict):
            if not groups:
                return await update.message.reply_text("‚ÑπÔ∏è ŸáŸÜŸàÿ≤ Ÿá€å⁄Ü ⁄Øÿ±ŸàŸá€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá.")
            text = "üìà ÿ¢ŸÖÿßÿ± ⁄©ÿßŸÖŸÑ ⁄Øÿ±ŸàŸá‚ÄåŸáÿß:\n\n"
            for gid, info in groups.items():
                title = info.get("title", f"Group_{gid}")
                members = len(info.get("members", []))
                last = info.get("last_active", "ŸÜÿßŸÖÿ¥ÿÆÿµ")
                try:
                    chat = await context.bot.get_chat(gid)
                    if chat.title:
                        title = chat.title
                except:
                    pass
                text += f"üè† ⁄Øÿ±ŸàŸá: {title}\nüë• ÿßÿπÿ∂ÿß: {members}\nüïì ÿ¢ÿÆÿ±€åŸÜ ŸÅÿπÿßŸÑ€åÿ™: {last}\n\n"
        else:
            return await update.message.reply_text("‚ö†Ô∏è ÿ≥ÿßÿÆÿ™ÿßÿ± group_data.json ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™!")

        if len(text) > 4000:
            text = text[:3990] + "..."

        await update.message.reply_text(text)
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿ¢ŸÖÿßÿ± ⁄Øÿ±ŸàŸá‚ÄåŸáÿß:\n{e}")


# ======================= üëã ÿÆŸàÿ¥ÿßŸÖÿØ =======================
async def welcome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not status["welcome"]:
        return
    for member in update.message.new_chat_members:
        now = datetime.now().strftime("%Y-%m-%d %H:%M")
        text = (
            f"üéâ ÿÆŸàÿ¥ ÿßŸàŸÖÿØ€å {member.first_name}!\n"
            f"üìÖ {now}\n"
            f"üè† ⁄Øÿ±ŸàŸá: {update.message.chat.title}\n"
            f"üòÑ ÿßŸÖ€åÿØŸàÿßÿ±ŸÖ ŸÑÿ≠ÿ∏ÿßÿ™ ÿÆŸàÿ®€å ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥€å!"
        )
        try:
            photos = await context.bot.get_user_profile_photos(member.id, limit=1)
            if photos.total_count > 0:
                file_id = photos.photos[0][-1].file_id
                await update.message.reply_photo(file_id, caption=text)
            else:
                await update.message.reply_text(text)
        except:
            await update.message.reply_text(text)


# ======================= ‚òÅÔ∏è ÿ®⁄©‚Äåÿ¢Ÿæ =======================
async def auto_backup(context: ContextTypes.DEFAULT_TYPE):
    while True:
        await asyncio.sleep(43200)
        await cloudsync_internal(context.bot, "Auto Backup")


async def cloudsync_internal(bot, reason="Manual Backup"):
    now = datetime.now().strftime("%Y-%m-%d_%H-%M")
    filename = f"backup_{now}.zip"
    with zipfile.ZipFile(filename, "w") as zipf:
        for root, _, files in os.walk("."):
            for file in files:
                if file.endswith((".json", ".jpg", ".png", ".webp", ".mp3", ".ogg", ".zip")):
                    zipf.write(os.path.join(root, file))
    try:
        await bot.send_document(chat_id=ADMIN_ID, document=open(filename, "rb"), filename=filename)
        await bot.send_message(chat_id=ADMIN_ID, text=f"‚òÅÔ∏è {reason} ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ ‚úÖ")
    except Exception as e:
        print(f"[CLOUD BACKUP ERROR] {e}")
    finally:
        os.remove(filename)


async def cloudsync(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    await cloudsync_internal(context.bot, "Manual Cloud Backup")


# ======================= üí¨ Ÿæÿßÿ≥ÿÆ Ÿà €åÿßÿØ⁄Ø€åÿ±€å =======================
async def reply(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        return

    text = update.message.text.strip()
    uid = update.effective_user.id
    chat_id = update.effective_chat.id

    register_user(uid)
    register_group_activity(chat_id, uid)

    if not status["locked"]:
        auto_learn_from_text(text)

    if not status["active"]:
        shadow_learn(text, "")
        return

    # ‚úÖ ÿ¨Ÿà⁄©‚ÄåŸáÿß Ÿà ŸÅÿßŸÑ‚ÄåŸáÿß
    if text == "ÿ¨Ÿà⁄©":
        if os.path.exists("jokes.json"):
            data = load_data("jokes.json")
            if data:
                key, val = random.choice(list(data.items()))
                t = val.get("type", "text")
                v = val.get("value", "")
                try:
                    if t == "text":
                        await update.message.reply_text("üòÇ " + v)
                    elif t == "photo":
                        await update.message.reply_photo(photo=open(v, "rb"), caption="üòÇ ÿ¨Ÿà⁄© ÿ™ÿµŸà€åÿ±€å!")
                    elif t == "video":
                        await update.message.reply_video(video=open(v, "rb"), caption="üòÇ ÿ¨Ÿà⁄© Ÿà€åÿØ€åŸà€å€å!")
                    elif t == "sticker":
                        await update.message.reply_sticker(sticker=open(v, "rb"))
                except Exception as e:
                    await update.message.reply_text(f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ≥ÿßŸÑ ÿ¨Ÿà⁄©: {e}")
            else:
                await update.message.reply_text("Ÿá€å⁄Ü ÿ¨Ÿà⁄©€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá üòÖ")
        return

    if text == "ŸÅÿßŸÑ":
        if os.path.exists("fortunes.json"):
            data = load_data("fortunes.json")
            if data:
                key, val = random.choice(list(data.items()))
                t = val.get("type", "text")
                v = val.get("value", "")
                try:
                    if t == "text":
                        await update.message.reply_text("üîÆ " + v)
                    elif t == "photo":
                        await update.message.reply_photo(photo=open(v, "rb"), caption="üîÆ ŸÅÿßŸÑ ÿ™ÿµŸà€åÿ±€å!")
                    elif t == "video":
                        await update.message.reply_video(video=open(v, "rb"), caption="üîÆ ŸÅÿßŸÑ Ÿà€åÿØ€åŸà€å€å!")
                    elif t == "sticker":
                        await update.message.reply_sticker(sticker=open(v, "rb"))
                except Exception as e:
                    await update.message.reply_text(f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ≥ÿßŸÑ ŸÅÿßŸÑ: {e}")
            else:
                await update.message.reply_text("Ÿá€å⁄Ü ŸÅÿßŸÑ€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá üòî")
        return

    # ‚úÖ ÿ´ÿ®ÿ™ ÿ¨Ÿà⁄© Ÿà ŸÅÿßŸÑ
    if text.lower() == "ÿ´ÿ®ÿ™ ÿ¨Ÿà⁄©" and update.message.reply_to_message:
        await save_joke(update)
        return

    if text.lower() == "ÿ´ÿ®ÿ™ ŸÅÿßŸÑ" and update.message.reply_to_message:
        await save_fortune(update)
        return

    # ‚úÖ ŸÑ€åÿ≥ÿ™‚ÄåŸáÿß
    if text == "ŸÑ€åÿ≥ÿ™ ÿ¨Ÿà⁄©‚ÄåŸáÿß":
        await list_jokes(update)
        return

    if text == "ŸÑ€åÿ≥ÿ™ ŸÅÿßŸÑ‚ÄåŸáÿß":
        await list_fortunes(update)
        return

    if text == "ŸÑ€åÿ≥ÿ™":
        await update.message.reply_text(list_phrases())
        return

    # ‚úÖ €åÿßÿØ⁄Ø€åÿ±€å ŸáŸàÿ¥ŸÖŸÜÿØ
    if text.startswith("€åÿßÿØÿ®⁄Ø€åÿ± "):
        parts = text.replace("€åÿßÿØÿ®⁄Ø€åÿ± ", "").split("\n")
        if len(parts) > 1:
            phrase = parts[0].strip()
            responses = [p.strip() for p in parts[1:] if p.strip()]
            msg = learn(phrase, *responses)
            await update.message.reply_text(msg)
        else:
            await update.message.reply_text("‚ùó ÿ®ÿπÿØ ÿßÿ≤ '€åÿßÿØÿ®⁄Ø€åÿ±' ÿ¨ŸÖŸÑŸá Ÿà Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿßÿ¥ ÿ±Ÿà ÿ®ÿß ÿÆÿ∑ ÿ¨ÿØ€åÿØ ÿ®ŸÜŸà€åÿ≥.")
        return

    if text == "ÿ¨ŸÖŸÑŸá ÿ®ÿ≥ÿßÿ≤":
        await update.message.reply_text(generate_sentence())
        return

    learned_reply = get_reply(text)
    if learned_reply:
        reply_text = enhance_sentence(learned_reply)
    else:
        emotion = detect_emotion(text)
        reply_text = smart_response(text, emotion) or enhance_sentence(text)

    await update.message.reply_text(reply_text)


# ======================= üì® ÿßÿ±ÿ≥ÿßŸÑ ŸáŸÖ⁄ØÿßŸÜ€å =======================
async def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return

    msg = " ".join(context.args)
    if not msg:
        return await update.message.reply_text("‚ùó ÿ®ÿπÿØ ÿßÿ≤ /broadcast Ÿæ€åÿßŸÖ ÿ±ÿß ÿ®ŸÜŸà€åÿ≥.")

    data_users = load_data("memory.json").get("users", [])
    data_groups = load_data("group_data.json").get("groups", {})

    group_ids = []
    if isinstance(data_groups, dict):
        group_ids = list(data_groups.keys())
    elif isinstance(data_groups, list):
        group_ids = [g.get("id") for g in data_groups if "id" in g]

    sent = 0
    failed = 0

    # üì© ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ
    for uid in data_users:
        try:
            await context.bot.send_message(chat_id=uid, text=msg)
            sent += 1
        except:
            failed += 1

    # üì¢ ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá ⁄Øÿ±ŸàŸá‚ÄåŸáÿß
    for gid in group_ids:
        try:
            await context.bot.send_message(chat_id=int(gid), text=msg)
            sent += 1
        except:
            failed += 1

    await update.message.reply_text(f"üì® Ÿæ€åÿßŸÖ ÿ®Ÿá {sent} ⁄Üÿ™ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØ ‚úÖ\n‚ö†Ô∏è ÿ¥⁄©ÿ≥ÿ™‚ÄåÿÆŸàÿ±ÿØŸá: {failed}")


# ======================= üö™ ÿÆÿ±Ÿàÿ¨ ÿßÿ≤ ⁄Øÿ±ŸàŸá =======================
async def leave(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id == ADMIN_ID:
        await update.message.reply_text("ü´° ÿÆÿØÿßŸÅÿ∏! ÿ™ÿß ÿØ€åÿØÿßÿ± ÿ®ÿπÿØ€å üòÇ")
        await context.bot.leave_chat(update.message.chat.id)


# ======================= üöÄ ÿßÿ¨ÿ±ÿß€å ŸÜŸáÿß€å€å =======================
if __name__ == "__main__":
    print("ü§ñ ÿÆŸÜ⁄ØŸàŸÑ ŸÅÿßÿ±ÿ≥€å 8.5.1 Cloud+ Supreme Pro Stable+ ÿ¢ŸÖÿßÿØŸá ÿ®Ÿá ÿÆÿØŸÖÿ™ ÿßÿ≥ÿ™ ...")

    app = ApplicationBuilder().token(TOKEN).build()
    app.add_error_handler(handle_error)

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("toggle", toggle))
    app.add_handler(CommandHandler("welcome", toggle_welcome))
    app.add_handler(CommandHandler("lock", lock_learning))
    app.add_handler(CommandHandler("unlock", unlock_learning))
    app.add_handler(CommandHandler("mode", mode_change))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CommandHandler("fullstats", fullstats))
    app.add_handler(CommandHandler("backup", cloudsync))
    app.add_handler(CommandHandler("reset", start))
    app.add_handler(CommandHandler("reload", start))
    app.add_handler(CommandHandler("broadcast", broadcast))
    app.add_handler(CommandHandler("leave", leave))

    app.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, welcome))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, reply))

    async def on_startup(app):
        await notify_admin_on_startup(app)
        app.create_task(auto_backup(app))
        print("üåô [SYSTEM] Startup tasks scheduled‚úÖ")

    app.post_init = on_startup
    app.run_polling(allowed_updates=Update.ALL_TYPES)
