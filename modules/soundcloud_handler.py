# modules/soundcloud_handler.py

import os
import asyncio
import yt_dlp
from concurrent.futures import ThreadPoolExecutor
import json

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes

# ================================
# Ø³ÙˆØ¯ÙˆÙ‡Ø§
# ================================
SUDO_USERS = [8588347189]  # â† Ø¢ÛŒØ¯ÛŒ Ø´Ù…Ø§

# ================================
# ØªÙ†Ø¸ÛŒÙ…Ø§Øª
# ================================
DOWNLOAD_FOLDER = "downloads"
os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)

COOKIE_FILE = "modules/youtube_cookie.txt"

executor = ThreadPoolExecutor(max_workers=8)

track_store = {}

# ================================
# Ú©Ø´ ØªÙ„Ú¯Ø±Ø§Ù… (file_id)
# ================================
CACHE_FILE = "data/sc_cache.json"
os.makedirs("data", exist_ok=True)

if not os.path.exists(CACHE_FILE):
    with open(CACHE_FILE, "w", encoding="utf-8") as f:
        json.dump({}, f)

with open(CACHE_FILE, "r", encoding="utf-8") as f:
    try:
        SC_CACHE = json.load(f)
    except:
        SC_CACHE = {}

def save_cache():
    with open(CACHE_FILE, "w", encoding="utf-8") as f:
        json.dump(SC_CACHE, f, ensure_ascii=False, indent=2)

# ================================
# Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§
# ================================
LANG_MESSAGES = {
    "fa": {
        "searching": "ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ ... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯",
        "downloading": "â¬‡ï¸ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¢Ù‡Ù†Ú¯...",
        "select_song": "ğŸµ {n} Ø¢Ù‡Ù†Ú¯ Ù¾ÛŒØ¯Ø§ Ø´Ø¯ â€” Ù„Ø·ÙØ§Ù‹ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        "notfound": "âŒ Ø¯Ø± SoundCloud Ú†ÛŒØ²ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯. Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± ÛŒÙˆØªÛŒÙˆØ¨...",
    }
}

# ================================
# ØªÙ†Ø¸ÛŒÙ…Ø§Øª yt_dlp
# ================================
BASE_OPTS = {
    "format": "bestaudio/best",
    "quiet": True,
    "outtmpl": f"{DOWNLOAD_FOLDER}/%(id)s.%(ext)s",
    "noprogress": True,
    "nopart": True,
    "retries": 20,
    "fragment_retries": 20,
    "concurrent_fragment_downloads": 20,
    "overwrites": True,
    "postprocessors": [
        {
            "key": "FFmpegExtractAudio",
            "preferredcodec": "mp3",
            "preferredquality": "192",
        }
    ],
}

# ================================
# Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¯ÛŒØ± Ø¨ÙˆØ¯Ù†
# ================================
async def is_admin(update, context):
    chat = update.effective_chat
    user = update.effective_user

    if chat.type == "private":
        return True
    if user.id in SUDO_USERS:
        return True
    try:
        admins = await context.bot.get_chat_administrators(chat.id)
        return user.id in [a.user.id for a in admins]
    except:
        return False

# ================================
# Ú†Ú© Ú©Ø´ mp3
# ================================
def cache_check(id_: str):
    for file in os.listdir(DOWNLOAD_FOLDER):
        if file.startswith(id_) and file.endswith(".mp3"):
            return os.path.join(DOWNLOAD_FOLDER, file)
    return None

# ================================
# Ø¯Ø§Ù†Ù„ÙˆØ¯ SoundCloud
# ================================
def _sc_download_sync(url: str):
    opts = BASE_OPTS.copy()
    with yt_dlp.YoutubeDL(opts) as y:
        info = y.extract_info(url, download=True)
        tid = str(info.get("id"))
        cached = cache_check(tid)
        if cached:
            return info, cached
        fname = y.prepare_filename(info)
        mp3 = fname.rsplit(".", 1)[0] + ".mp3"
        return info, mp3

# ================================
# Ø¯Ø§Ù†Ù„ÙˆØ¯ fallback ÛŒÙˆØªÛŒÙˆØ¨
# ================================
def _youtube_fallback_sync(query: str):
    opts = BASE_OPTS.copy()
    opts["concurrent_fragment_downloads"] = 20
    if os.path.exists(COOKIE_FILE):
        opts["cookiefile"] = COOKIE_FILE
    with yt_dlp.YoutubeDL(opts) as y:
        info = y.extract_info(f"ytsearch1:{query}", download=True)
        if "entries" in info:
            info = info["entries"][0]
        vid = str(info.get("id"))
        cached = cache_check(vid)
        if cached:
            return info, cached
        fname = y.prepare_filename(info)
        mp3 = fname.rsplit(".", 1)[0] + ".mp3"
        return info, mp3

# ================================
# Ù‡Ù†Ø¯Ù„Ø± Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§
# ================================
async def soundcloud_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        return

    text = update.message.text.strip()
    triggers = ["Ø¢Ù‡Ù†Ú¯ ", "music ", "Ø§ØºÙ†ÙŠØ© ", "Ø£ØºÙ†ÙŠØ© "]

    if not any(text.lower().startswith(t) for t in triggers):
        return

    if update.effective_chat.type != "private" and not await is_admin(update, context):
        return

    query = next((text[len(t):].strip() for t in triggers if text.lower().startswith(t)), "")
    lang = "fa"

    msg = await update.message.reply_text(LANG_MESSAGES[lang]["searching"])
    loop = asyncio.get_running_loop()

    # ØªÙ„Ø§Ø´ SoundCloud
    try:
        info, mp3 = await loop.run_in_executor(executor, _sc_download_sync, query)
    except Exception:
        info, mp3 = None, None

    if not info:
        # fallback ÛŒÙˆØªÛŒÙˆØ¨
        await msg.edit_text(LANG_MESSAGES[lang]["notfound"])
        try:
            info, mp3 = await loop.run_in_executor(executor, _youtube_fallback_sync, query)
        except Exception as e:
            return await msg.edit_text(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ ÛŒÙˆØªÛŒÙˆØ¨:\n{e}")

    # Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„
    cache_key = f"sc_{str(info.get('id'))}"
    if cache_key in SC_CACHE:
        try: await msg.delete()
        except: pass
        return await update.message.reply_audio(SC_CACHE[cache_key], caption=f"ğŸµ {info.get('title', 'Music')}")

    try:
        with open(mp3, "rb") as f:
            sent = await update.message.reply_audio(f, caption=f"ğŸµ {info.get('title', 'Music')}")
    except Exception as e:
        return await msg.edit_text(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„:\n{e}")
    finally:
        if os.path.exists(mp3):
            os.remove(mp3)

    SC_CACHE[cache_key] = sent.audio.file_id
    save_cache()

    try:
        await msg.delete()
    except:
        pass

# ================================
# Ù‡Ù†Ø¯Ù„Ø± Ø¯Ú©Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨
# ================================
async def music_select_handler(update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    chat = cq.message.chat.id

    track_id = cq.data.split(":")[1]
    cache_key = f"sc_{track_id}"

    if cache_key in SC_CACHE:
        try: await cq.edit_message_text("âš¡ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø§Ø² Ú©Ø´ ØªÙ„Ú¯Ø±Ø§Ù…...")
        except: pass
        return await context.bot.send_audio(chat, SC_CACHE[cache_key])
